<h1 align="center">Labs9 Knowledge Without College</h1>
<div align="center"> <img src="https://i.ibb.co/8cjQJn1/logo-with-light-green-text.png" alt="Knoledge Without College Blue and Orange Logo"/></div>

<div align="center"><h2>Brought to you by:</h2>

<a href="https://github.com/brianmgre">Brian Gregorious</a>

<a href="https://github.com/Charletta">Charletta Bullard</a>

<a href="https://github.com/sarahtennis">Sarah Tennis</a>

<a href="https://github.com/SavannahGreuel">Savannah Greuel</a>

<a href="https://github.com/yusufnafey">Yusuf Nafey</a>
</div>
<br>
<br>

<!-- Table Of Contents -->

<!-- Tech Stack -->
# Tech Stack
### Frontend built using:
* React.js
* SCSS
* Netlify

Deployed [here](https://knowledge-without-college.netlify.com/)

### Backend built using:
* PostgresQL
* Knex
* Express
* Node.js
* Heroku

Deployed [here](https://knowledge-without-college.herokuapp.com/test)

<!-- Reasoning -->
##Reasoning

* React.js
    * We chose to work with React as our framework. When we planned out how we were going to build out our application, we noticed that our components would be interacting with one another. Not only that, but the components were being reused in many different situations. Using a framework like React, which helps with the user experience and an has increased speed with the virtual DOM, seemed like the best route to take.

* Netlify
    * Although problems can arise if this application were to be used on a larger scale, we decided to work with Netlify for two main reasons. First and most importantly, all of the members on our team have previously been exposed to Netlify and we were at least somewhat familiar with it. Aside from that, we didn’t have the intention to use this application on a larger scale, at least in the near future.

* PostgreSQL
    * Because many of the components in our application were related to one another, we decided to use an SQL database like PostgreSQL. PostgreSQL supports JSON and has no transitioning query languages for deployment. Our data was also relational, which worked perfectly with PostgreSQL.

* Express/Node.js
    * Using Express and Node.js was a no brainer for all the members on our team. It offers a large number of free tools and the speed and performance of these solutions is known to be exceptional. It works with JSON, which is what we planned on using. Not only that, but it maintains the same language throughout the project both on the client and the server.

* Heroku
    * The reasoning behind using Heroku was similar to the reasoning for the use of Netlify. We were all familiar with Heroku and didn’t plan to use this application on a large scale anytime soon, so in this situation using a deployment site like Heroku seemed like the most logical route to take.

* CSS/SCSS
    * We decided to stick with plain old styling rather than use a component library like ReactStrap or Material UI for a number of reasons. It gave us more flexibility in terms of how we wanted to style our components. Not only that, but there was nobody on our team that had been familiar with an outside component library, so we stuck with regular styling. On top of that, using SCSS as our preprocessor made the process much easier with the accessibility to variables and mixins.


<!-- Testing -->
<!-- Installation Instructions -->
<!-- Contributing -->
<!-- Data Modals -->
<!-- Postgres -->
<!-- Stripe -->
<!-- Cloudinary-->
<!-- Firebase -->
<!-- Payment Structure -->
<!-- Design-->
